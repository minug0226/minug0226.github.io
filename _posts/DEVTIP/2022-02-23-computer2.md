---
title:  "컴퓨터 공학 기초 : 운영체제, 가비지 컬렉션, 캐시 "
excerpt: "정말 컴퓨터 공학은 방대하다.."

categories:
  - DevTip
tags:
  - [ DevTip ]

toc: true
toc_sticky: true

date: 2022-02-23
last_modified_at: 2022-02-23
---

컴퓨터나 스마트폰의 기기 그 자체(하드웨어)는 스스로 할 수 있는 일이 없다. 하드웨어의 설계를 바탕으로 하드웨어에게 일을 시켜야만 그 의미가 있다. 하드웨어에게 일을 시키는 주체가 바로 운영체제이다.

# 운영체제
## 시스템 자원 관리
운영체제가 없다면, 응용 프로그램이 실행될 수 없다. 응용 프로그램은 컴퓨터를 이용해 다양한 작업을 하는 것이 목적이고, 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와준다. 하드웨어를 구성하는 일을 하는 `CPU`, 자료를 저장하는 `RAM`, 디스크 등의 시스템 자원을 관리하는 주체가 바로 운영체제이다.

- 프로세스 관리(CPU)
- 메모리 관리
- I/O(입출력) 관리 (디스크, 네트워크 등)
`운영체제의 구조 모식도`




![image](https://user-images.githubusercontent.com/85049368/155314619-eb0b3241-a0bb-4e4a-bdf2-1265ca226c26.png)

## 응용 프로그램 관리
모든 응용 프로그램이 시스템의 자원을 마음대로 사용한다면, 해커에 의한 공격에 무방비한 상태가 된다. 악의적인 목적을 가진 프로그램이 디스크의 모든 민감한 정보에 접근하거나, 내 스마트폰의 특정 앱이 카메라를 아무 때나 실행해서 촬영한다고 생각하면 끔직하다. 따라서, 응용 프로그램은 권한에 대한 관리가 필요하다. 또한 여러 사람이 하나의 기기를 사용하는 경우에는 사용자를 관리하는 일도 매우 중요하다.

응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자를 관리한다.
## 응용 프로그램: 운영체제를 통해 컴퓨터에게 일을 시키는 것

응용 프로그램이 운영체제를 통해 컴퓨터에게 일을 시키려면, 컴퓨터를 조작할 수 있는 권한을 운영체제로부터 부여받아야 한다. 권한을 부여받고 난 후에는, 운영체제가 제공하는 기능을 이용할 수 있다. 응용 프로그램이 운영체제와 소통하기 위해서는, 운영체제가 응용 프로그램을 위해 인터페이스(API)를 제공해야 한다. 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수를 제공하는 것을 시스템 콜(System call)이라고 부른다.

스마트폰에서 사용자에게 어떤 디바이스(카메라 등)의 사용을 허락받는 화면을 본 적이 있을 것이다. 이와 마찬가지로, 응용 프로그램 역시 운영체제가 프린터 사용을 허가해 주지 않는다면 사용할 수 없다. 워드프로세서 프로그램이 프린터를 사용해서 인쇄하기 위해서는, 워드프로세서 프로그램은 운영체제로부터 프린터 사용에 대한 권한을 부여받아야 한다.

응용 프로그램이 프린터 사용에 대한 권한을 획득한 후에는, 프린터를 사용할 때 필요한 API를 호출해야 한다. 이 API는 시스템 콜로 이루어져 있다.


소위 공룡책이라 불리는 Operating System Concepts 책이 있는데 이미 정리된 한글 문서도 존재하니까 여길 보면서 더 공부하자. -> [공룡책 한글문서](https://parksb.github.io/article/5.html)

# 프로세스(Process)
운영체제에서는 실행 중인 하나의 애플리케이션을 프로세스라고 부른다. 사용자가 애플리케이션을 실행하면, 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행한다. 이때 실행되는 애플리케이션을 프로세스라고 부른다. 예를 들어 Chrome 브라우저를 두 개 실행하면, 두 개의 프로세스가 생성된다. 이렇게 하나의 애플리케이션은 여러 프로세스(다중 프로세스)를 만들기도 한다.

다음 사진에서 확인할 수 있는 항목 하나하나가 전부 프로세스이다.

`활성 상태창(macOS, Windows에서는 작업관리자) 예시`



![image](https://user-images.githubusercontent.com/85049368/155315365-8e864139-3d0f-476e-a5de-c584fb680b88.png)


# 스레드(Thread)
스레드는 사전적 의미로 한 가닥의 실이라는 뜻이다. 한 가지 작업을 실행하기 위해 순차적으로 실행한 코드를 실처럼 이어 놓았다고 해서 유래된 이름이다. 하나의 스레드는 코드가 실행되는 하나의 흐름이기 때문에, 한 프로세스 내에 스레드가 두 개라면 코드가 실행되는 흐름이 두 개 생긴다는 의미이다.

# 멀티 스레드(Multi-Thread)
멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 의미한다. 운영체제는 멀티 태스킹을 할 수 있도록, 프로세스마다 CPU 및 메모리 자원을 적절히 할당하고 병렬로 실행한다. 예를 들어 워드로 문서작업을 하면서, 동시에 Chrome 브라우저에서 음악을 들을 수 있다. 물론 멀티 태스킹은 꼭 멀티 프로세스를 의미하는 것은 아니다. 하나의 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 애플리케이션도 있다. 하나의 프로세스가 어떻게 두 가지 이상의 작업을 처리할 수 있을까? 그 비밀은 멀티 스레드에 있다.

멀티 프로세스가 애플리케이션 단위의 멀티 태스킹이라면, 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라고 할 수 있다.

멀티 스레드는 다양한 곳에서 사용된다. 대용량 데이터의 처리시간을 줄이기 위해 데이터를 분할하여 병렬로 처리하는 데에 사용할 수도 있고, UI를 가지고 있는 애플리케이션에서 네트워크 통신을 하기 위해 사용할 수도 있다. 그리고 여러 클라이언트의 요청을 처리하는 서버를 개발할 때에도 사용된다.

`프로세스와 멀티 스레드 예시`



![image](https://user-images.githubusercontent.com/85049368/155315403-923870df-6f5e-4e54-8a08-fdf8c5aa458f.png)

# 프로세스와 스레드 구성

![image](https://user-images.githubusercontent.com/85049368/155315602-c12a0f2e-6f30-4fbd-a489-9c8af334e3c5.png)

## 1. 스레드의 특징
- 프로세스 내에서 실행되는 흐름의 단위
- 각 스레드마다 call stack이 존재(call stack: 실행 중인 서브루틴을 저장하는 자료 구조)
- 스레드는 다른 스레드와 독립적으로 동작
  
## 2. 멀티 스레딩의 장점
프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우, 메모리 공간과 시스템 자원의 소모가 줄어든다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용한다. 따라서, 프로세스 간 통신 방법(IPC)에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 시스템의 처리량(Throughput)이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축된다. 이런 장점 때문에 여러 프로세스로 할 수 있는 작업을 하나의 프로세스에서 스레드로 나눠 수행한다.

## 3. 멀티 스레딩의 문제점
멀티 프로세스 기반으로 프로그래밍할 때에는 프로세스 간 공유하는 자원이 없다. 따라서 동일한 자원에 동시에 접근하는 일이 없었지만, 멀티 스레딩을 기반으로 프로그래밍할 때에는 공유하는 자원에 대하여 고민이 필요하다. 서로 다른 스레드가 같은 데이터에 접근하고, 힙 영역을 공유하기 때문에 서로 다른 스레드가 서로 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정하는 일이 발생할 수 있다.

그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 제어하고, 공유 자원에 대한 접근을 제어해야한다.

`관련 키워드`

```
데드락(Deadlock, 교착 상태)
뮤텍스(Mutex), 세마포어(Semaphore)
```
## 4. 동시성과 병렬성의 차이

`싱글 코어와 멀티 코어 예시`



![image](https://user-images.githubusercontent.com/85049368/155315825-119449ab-bac6-441c-9589-2b0a27ab10da.png)

- 동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 개수로 제한된다. 운영체제(또는 가상 머신)는 각 스레드를 시간에 따라 분할하여, 여러 스레드가 일정 시간마다 돌아가면서 실행되도록 한다. 이런 방식을 시분할이라고 한다.
  - Concurrency(동시성, 병행성): 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각을 불러일으킴
  - Parallelism(병렬성): 멀티 코어 환경에서 여러 개의 스레드가 실제로 동시에 수행됨
## 5. Context Switching이란?
다른 태스크(프로세스, 스레드)가 시작할 수 있도록 이미 실행 중인 태스크(프로세스, 스레드)를 멈추는 것을 Context Switching이라고 한다.


# 가비지 컬렉션

## 1. 가비지 컬렉션은 무엇이며, 가비지 컬렉션 기능을 가진 언어는 무엇인가?
가비지 컬렉션은 프로그램에서 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것이다. 이 기능을 가진 언어(혹은 엔진)는 `자바`, `C#`, `자바스크립트` 등이 있다.

## 2. 대표적인 가비지 컬렉션의 방법은 무엇이 있나?
- 트레이싱: 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법이다.객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지 아닌지를 표시(mark)한다. 그 후 표시되지 않은 객체를 삭제(sweep)하는 단계를 통해 메모리를 해제한다.

- 레퍼런스 카운팅: 한 객체를 참조하는 변수의 수를 추적하는 방법이다.객체를 참조하는 변수는 처음에는 특정 메모리에 대해 레퍼런스가 하나뿐이지만, 변수의 레퍼런스가 복사될 때마다 레퍼런스 카운트가 늘어난다. 객체를 참조하고 있던 변수의 값이 바뀌거나, 변수 스코프를 벗어나면 레퍼런스 카운트는 줄어든다. 레퍼런스 카운트가 0이 되면, 그 객체와 관련한 메모리는 비울 수 있다. 레퍼런스 카운트가 0이 된다는 말은 아무도 그 객체에 대한 레퍼런스를 가지고 있지 않다는 말과 같다.

# 웹 서비스에서의 캐시

## 1. 캐시란 무엇인가?
많은 시간이나 연산이 필요한 작업의 결과를 저장해두는 것을 의미한다.
컴퓨팅에서 캐시는 일반적으로 일시적인(temporarily) 데이터를 저장하기 위한 목적으로 존재하는 고속의 데이터 저장 공간이다. 첫 작업 이후에 이 데이터에 대한 요청이 있을 경우, 데이터의 기본 저장 공간에 접근할 때보다 더 빠르게 요청을 처리할 수 있다. 캐싱을 사용하면 이전에 검색하거나 계산한 데이터를 효율적으로 재사용할 수 있다.

## 2. 캐시의 일반적인 작동원리
캐시의 데이터는 일반적으로 RAM(Random Access Memory)과 같이 빠르게 액세스할 수 있는 하드웨어에 저장되며, 소프트웨어 구성 요소와 함께 사용될 수도 있다. 캐시는 기본 스토리지 계층(SSD, HDD)에 액세스하여 데이터를 가져오는 더 느린 작업의 요구를 줄이고, 데이터 검색의 성능을 높인다.

속도를 위해 용량을 절충하는 캐시는 일반적으로 데이터의 하위 집합을 일시적으로 저장한다. 완전하고 영구적인 데이터가 있는 데이터베이스와는 대조적이다.

## 3. 캐시의 장점은 무엇인가?
- 애플리케이션 성능 개선
- 데이터베이스 비용 절감
- 백엔드 부하 감소
- 예측 가능한 성능
- 데이터베이스 핫스팟 제거
- 읽기 처리량 증가
  - 읽기 처리량: IOPS; Input/output operations per second. HDD, SSD 등의 컴퓨터 저장 장치의 성능 측정 단위
## 4. 웹서비스에서 캐시가 적용되는 예제로는 어떤 것들이 있나?
- 클라이언트: HTTP 캐시 헤더, 브라우저
- 네트워크: DNS 서버, HTTP 캐시 헤더, CDN, 리버스 프록시
- 서버 및 데이터베이스: 키-값 데이터 스토어(e.g. Redis), 로컬 캐시(인-메모리, 디스크)

[더 알아보기](https://aws.amazon.com/ko/caching/)



***
    🐶 개인의 공부를 위한 블로그입니다. 🐶

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}

